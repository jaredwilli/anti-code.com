if (typeof anti !== 'object') {
	anti = {};
}

anti = {
	common: {
		init: function() {
			if ($('.lt-ie9').length) {
				console.log('This site is still being developed. Every example is loaded in the panels using ajax onclick of each nav link. Some of the projects which use JavaScript are still a little buggy but they work individually. Eventually they will be interactive and "playable" demo examples loaded into this page.');
			}

			// ie9 - Need to set cors to true for loading each projects assets
			$.support.cors = true;
			anti.init();
		}
	},
	/**!
	 * Stores the panels ID and CSS position coordinates for global access
	 * once generated by looping over the list of .panels
	 */
	panels: {
		activePanel: 'panel5',
		panelsLoaded: [],
		panelSliders: []
	},
	layers: {},
	pos: {},
	lastPos: {},
	slope: null,
	duration: null,
	ONE_SECOND: 1000,
	timer: new AnimationTimer(),

	init: function() {
		var b = document.body,
			p = $('.panel'),
			l = $('.layer');

		// load the initial panel's content
		anti.panels.panelsLoaded.push(anti.panels.activePanel);
		anti.panelContent.loadPanel(anti.panels.activePanel);

		// Set up an obj of each panel and their left/top position
		// Creates the anti.panels[panel] = { x, y } objects
		for (var i = 0; i < p.length; i++) {
			var panelId = $(p[i]).attr('id');

			// Skip the loading of panel5
			if (i !== 4) {
				$(p[i]).html('<div class="panel-wrap"></div>');
			}
			anti.panels[panelId] = {};
			anti.panels[panelId].pos = [];
			anti.panels[panelId].pos.push(
				Number($('#'+ panelId).css('left').split('px')[0]),
				Number($('#'+ panelId).css('top').split('px')[0])
			);
		}
		//console.log('panels: ', anti.panels);

		// Set up an obj of each layer and their left/top position
		// Creates the anti.layers[layer] = { x, y, w, h } objects
		for (var j = 0; j < l.length; j++) {
			var layerId = $(l[j]).attr('id');

			anti.layers[layerId] = {};
			anti.layers[layerId].pos = [];
			anti.layers[layerId].pos.push(
				Number($('#'+ layerId).css('left').split('px')[0]),
				Number($('#'+ layerId).css('top').split('px')[0]),
				Number($('#'+ layerId).css('width').split('px')[0]),
				Number($('#'+ layerId).css('height').split('px')[0])
			);
		}
		//console.log('layers: ', anti.layers);

		// Setup navigation
		anti.panelNavigation.setUp();

		var pos = {
			layer3pos: anti.layers.layer3.pos,
			xConst: (anti.panels.panel5.pos[0] - anti.layers.layer3.pos[2]) * 0.0001,
			yConst: (anti.panels.panel5.pos[1] - anti.layers.layer3.pos[3]) * 0.0991,
			slope: null
		};
		anti.canvas(pos, null);
		anti.pos = pos;

		// Make everything fill the browser viewport
		if (window.attachEvent/* && window.addEventListener !== 'undefined'*/) {
			window.attachEvent('onresize', anti.utils.resizeToScreen);
		} else {
			window.addEventListener('resize', anti.utils.resizeToScreen, false);
		}
		anti.utils.resizeToScreen();
	},

	panelNavigation: {
		// Constants for nav functionality
		BASE_DURATION: 1000,
		MAX_DURATION: 4000,
		EASING_TYPE: 'easeOutQuart', // easeOutQuart',
		MENU_SET: $('#main-nav, #default-nav').find('a'),

		// sets up handlers on nav elements and maps handlers, with target params
		setUp: function() {
			$('#default-nav li a').hover(function() {
				$(this).find('span').stop().animate({ bottom: 40 +'px'}, 500);
			}, function() {
				$(this).find('span').stop().animate({ bottom: 0 }, 500);
			});

			anti.panelNavigation.MENU_SET.on('click', function(e) {
				e.preventDefault();

				var panelToLoad = $(this).attr('href').split('#')[1];
				// TODO: incorporate the History.pushState to track URLS

				// set now to the section about to be loaded into view
				if (panelToLoad === anti.panels.activePanel) {
					return false;
				} else {
					anti.panels.activePanel = panelToLoad;
				}

				//console.log('panelToLoad: ', anti.panels[panelToLoad]);
				anti.panelNavigation.navigateToSection(panelToLoad);
			});

			// Make dropmenu
			/*$('#main-nav').find('h4').on('click', function(e) {
				e.preventDefault();

				if ($('.dropdown').hasClass('active')) {
					$('.dropdown').removeClass('active');
				} else {
					$('.dropdown').addClass('active');
				}

				$('.dropmenu').find('a').on('click', function(e) {
					e.preventDefault();
					var panelToLoad = $(this).attr('href').split('#')[1];
					anti.panelNavigation.navigateToSection(panelToLoad);
				});
			});*/
		},
		navigateToSection: function(panelToLoad) {
			//window.history.pushState(panelToLoad, $('#'+ panelToLoad).find('h2').text(), '#'+ panelToLoad);
			//window.location.hash = '#'+ panelToLoad;

			$('#main-nav, #default-nav').find('.active').removeClass('active');
			$('#main-nav, #default-nav').find('a[href=#' + panelToLoad + ']').addClass('active');

			// load target panel's content
			//anti.panelContent.loadPanel(panelToLoad);

			anti.panelNavigation.moveAll(panelToLoad);
		},

		// method accepts string of target panel for which to apply position translation animations
		// TODO: BIG TIME - this whole method needs to be done more abstractly and better!!!
		moveAll: function(panelToLoad) {
			//console.log('moveAll called!!');

			var winW = window.innerWidth,
				winH = window.innerHeight,
				leftPos = 100,
				topPos = 5;

			// For screens that are smaller than 1280
			if (winW < 1280) {
			}
			if (winW >= 1280) {
				leftPos = 100;
				topPos = 0;
			}

			// Store the last left / top position to find the slope
			var lastPos = anti.pos;

			var layer3pos = anti.panels[panelToLoad].pos !== 'undefined' ? anti.panels[panelToLoad].pos : '';
			layer3pos[0] = layer3pos[0] * -1 + leftPos,
			layer3pos[1] = layer3pos[1] * -1 + topPos;

			//	Eqaution: slope = ((y1 - y2) / (x1 - x2))

			// Slope difference of layer3
			//var slope = ((an.layerPos.layer3[1] - layer3y) / (an.layerPos.layer3[0] - layer3x));

			anti.layers.layer3.pos[2] = anti.panels.panel1.pos[0] - (anti.panels.panel3.pos[0] + winW);
			anti.layers.layer3.pos[3] = anti.panels.panel1.pos[1] - (anti.panels.panel3.pos[0] + winH);

			/**
			 * layer - anti.layer[layer].pos = [x, y, w, h]
			 *
			 * xConst/yConst = (panelToLoad.pos[x, y] - layer3[Width/Height]) * 0.0001; // times 10,000th
			 * layer1,4,5 x  = (layer1,4,5 Width / windowWidth) * ((panel.pos[x] - layer3width) * 0.0001) * 1000 * -1
			 * layers = anti.layer [x, y] - layer[x,y]
			 */

			var pos = {
				layer3pos: layer3pos,
				xConst: (anti.panels[panelToLoad].pos[0] - anti.layers.layer3.pos[2]) * 0.0001,
				yConst: (anti.panels[panelToLoad].pos[1] - anti.layers.layer3.pos[3]) * 0.0001,
				slope: ((lastPos.layer3y - layer3pos[1]) / (lastPos.layer3x - layer3pos[0]))
			};
			console.log(pos);
			anti.panelNavigation.animateEm(pos);
		},
		animateEm: function(pos) {
			var pn = anti.panelNavigation;

			// check for travel distance to set animation duration based on how far to slide
			var xDiff = Math.abs((anti.layers.layer3.pos[2] + 1000) - (pos.layer3pos[0] + 1000));

			// calculate the adjusted animation duration
			var thisDuration = (xDiff / (anti.layers.layer3.pos[2] * (pn.MAX_DURATION - pn.BASE_DURATION)) ) + pn.BASE_DURATION;

			//anti.timer = new AnimationTimer(thisDuration);

			// Start the animation timer
			anti.timer.start();

			// run the animations
			$('#layer3').stop().animate({
				left: pos.layer3pos[0] + 'px',
				top: pos.layer3pos[1] + 'px'
			}, thisDuration, pn.EASING_TYPE);

			anti.canvas(pos, thisDuration);
		}
	},

	canvas: function(pos, duration) {
		console.log('antiObj: ', anti.pos, pos);

		/**
		 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 *
		 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 *
		 *
		 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 */

		var canvas = document.getElementById('bgGame'),
			ctx = canvas.getContext('2d'),

			bCloud = new Image(),
			mCloud = new Image(),
			sCloud = new Image(),
			tree = new Image(),
			nearTree = new Image(),
			grass = new Image(),
			grass2 = new Image(),
			sky = new Image(),

			paused = true,
			lastTime = 0,
			lastFpsUpdate = { time: 0, value: 0 },
			fps = 60,

			grassOffset = 0,
			treeOffset = 0,
			nearTreeOffset = 0,
			bCloudOffset = {
				x: anti.pos.layer3x % pos.layer3pos[0],
				y: anti.pos.layer3y % pos.layer3pos[1]
			},
			mCloudOffset = { x: 0, y: 0 },
			sCloudOffset = { x: 0, y: 0 },

			BCLOUD_VELOCITY = 20,
			MCLOUD_VELOCITY = 40,
			SCLOUD_VELOCITY = 60,
			TREE_VELOCITY = 20,
			FAST_TREE_VELOCITY = 40,
			SKY_VELOCITY = 8,
			GRASS_VELOCITY = 75,

			skyFillStyle = 'rgba(65, 143, 255, 1)',

			ballz = [],
			numBallz = 10,

			Ball = function(x, y, radius, mass, vX, vY, aX, aY) {
				// position, size, mass
				this.x = x;
				this.y = y;
				this.radius = radius;
				this.maxRadius = radius * 0.02;
				this.mass = mass;
				// velocity
				this.vX = vX;
				this.vY = vY;
				// accelleration
				this.aX = aX;
				this.aY = aY;
			};

		// Create the balls
		for (var i = 0; i < numBallz; i++) {
			var x = 20 + (Math.random() * (canvas.width - 40)),
				y = 20 + (Math.random() * (canvas.height - 40)),
				radius = 15 + Math.random() * 25,
				mass = radius / 2;
				vX = Math.random() * 4 - 2,
				vY = Math.random() * 4 - 2, // random number between -2 and 2
				aX = 0.1,
				aY = 0.1;

			ballz.push(new Ball(x, y, radius, mass, vX, vY, aX, aY));
		}

		// Functions

		function erase() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		}

		function calcuateOffset(offset) {
			if (anti.slope === Infinity) {
				//console.log('Infinity', offset);
				ctx.translate(0, offset.y);
			} else if (anti.slope === -Infinity) {
				//console.log('-Infinity', offset);
				ctx.translate(0, -offset.y);
			} else if (anti.slope === 0) {
				ctx.translate(-offset.x, 0);
			} else {
				if (anti.slope > 0) {
					ctx.translate(offset.x, offset.y);
				} else if (anti.slope < 0) {
					ctx.translate(-offset.x, -offset.y);
				}
			}
			return offset;
		}

		function smallTree(ctx, callback) {
			var treesX = [ 100,	1100, 400, 1400, 700, 1700 ];
			//console.log(callback);

			treeOffset = (treeOffset < canvas.width) ? treeOffset + TREE_VELOCITY / fps : 0;
			ctx.save();
				callback(treeOffset);

				for (var i = 0; i < treesX.length; i++) {
					ctx.drawImage(tree, treesX[i], canvas.height - tree.height - 24);
				}
			ctx.restore();
		}

		function bigTree(ctx, callback) {
			var treesX = [ 100, 1250, 800, 1800 ];
			//console.log(callback);

			nearTreeOffset = (nearTreeOffset < canvas.width) ? nearTreeOffset + FAST_TREE_VELOCITY / fps : 0;

			ctx.save();
				callback(treeOffset);

				for (var i = 0; i < treesX.length; i++) {
					ctx.drawImage(nearTree, treesX[i], canvas.height - nearTree.height - 15);
				}
			ctx.restore();
		}

		function drawGrass(ctx, callback) {
			grassOffset = (grassOffset < canvas.width) ? grassOffset + GRASS_VELOCITY / fps : 0;

			ctx.save();
				callback(grassOffset);

					ctx.drawImage(grass, 0, canvas.height - grass.height);
					ctx.drawImage(grass, grass.width - 5, canvas.height - grass.height);
					ctx.drawImage(grass2, 0, canvas.height - grass2.height);
					ctx.drawImage(grass2, grass2.width, canvas.height - grass2.height);
			ctx.restore();
		}

		function smallClouds(ctx, callback) {
			sCloudOffset.x = (sCloudOffset.x < canvas.width) ? sCloudOffset.x + SCLOUD_VELOCITY / fps : 0;
			sCloudOffset.y = (sCloudOffset.y < canvas.height) ? sCloudOffset.y + SCLOUD_VELOCITY / fps : 0;

			ctx.save();
				//callback(sCloudOffset);

				ctx.drawImage(bCloud, sCloudOffset.x, sCloudOffset.y, bCloud.width / 3, bCloud.height / 3);

				/*ctx.drawImage(bCloud, 300, 200, bCloud.width / 3, bCloud.height / 3);
				ctx.drawImage(bCloud, 500, 200, bCloud.width / 3, bCloud.height / 3);
				ctx.drawImage(bCloud, 0, 200, bCloud.width / 3, bCloud.height / 3);
				ctx.drawImage(bCloud, 0, 200, bCloud.width / 3, bCloud.height / 3);*/
			ctx.restore();
		}
		function mediumClouds(ctx, callback) {
			mCloudOffset.x = (mCloudOffset.x < canvas.width) ? mCloudOffset.x + MCLOUD_VELOCITY / fps : 0;
			mCloudOffset.y = (mCloudOffset.y < canvas.height) ? mCloudOffset.y + MCLOUD_VELOCITY / fps : 0;
			//console.log('mCloudOffset: ', mCloudOffset);

			ctx.save();
				//callback(mCloudOffset);

				ctx.drawImage(bCloud, mCloudOffset.x, mCloudOffset.y, bCloud.width / 2, bCloud.height / 2);

				/*ctx.drawImage(bCloud, 310, 120, bCloud.width / 2, bCloud.height / 2);
				ctx.drawImage(bCloud, 510, 20, bCloud.width / 2, bCloud.height / 2);
				ctx.drawImage(bCloud, 680, 620, bCloud.width / 2, bCloud.height / 2);*/
			ctx.restore();
		}
		function bigClouds(ctx, callback) {
			bCloudOffset.x = Math.round((bCloud.width / window.innerWidth) * ((pos.layer3pos[0] - anti.layers.layer3.pos[2]) * 0.0001) * 1000 * -1);
			bCloudOffset.y = Math.round((bCloud.height / window.innerHeight) * ((pos.layer3pos[1] - anti.layers.layer3.pos[3]) * 0.0001) * 1000 * -1);
			console.log("x", bCloudOffset.x, bCloudOffset.y);

			//bCloudOffset.x = (bCloudOffset.x < canvas.width) ? bCloudOffset.x + BCLOUD_VELOCITY / fps : 0;
			//bCloudOffset.y = (bCloudOffset.y < canvas.height) ? bCloudOffset.y + BCLOUD_VELOCITY / fps : 0;

			ctx.save();
				//callback(bCloudOffset);
				//ctx.translate(bCloudOffset.x, bCloudOffset.y);

				var pattern = ctx.createPattern(bCloud, 'repeat');
				ctx.fillStyle = pattern;
				ctx.fillRect(0, 0, canvas.width, canvas.height);


				/*ctx.drawImage(bCloud, 200, 225);
				ctx.drawImage(bCloud, 555, 700);
				ctx.drawImage(bCloud, 905, 70);
				ctx.drawImage(bCloud, 1005, 570);*/
			ctx.restore();
		}

		function draw() {
			ctx.fillStyle = skyFillStyle;
			ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

			/**
			 * layer - anti.layer[layer].pos = [x, y, w, h]
			 *
			 * xConst/yConst = (panelToLoad.pos[x, y] - layer3[Width/Height]) * 0.0001; // times 10,000th
			 * layer1,4,5 x  = (layer1,4,5 Width / windowWidth) * ((panel.pos[x] - layer3width) * 0.0001) * 1000 * -1
			 */

			ctx.save();
				//skyOffset = (skyOffset < canvas.width) ? skyOffset + SKY_VELOCITY / fps : 0;

				//bigClouds(ctx, calcuateOffset);
				//mediumClouds(ctx, calcuateOffset);
				//smallClouds(ctx, calcuateOffset);

				smallTree(ctx, calcuateOffset);
				bigTree(ctx, calcuateOffset);

				drawGrass(ctx, calcuateOffset);
			ctx.restore();
		}

		function animateBalls() {
			for (var i = 0; i < ballz.length; i++) {
				var a = ballz[i];

				/* hyp = sqrt(x^2+y^2) */
				for (var j = i+1; j < ballz.length; j++) {
					var b = ballz[j];

					// Collision detection
					var dX = b.x - a.x,
						dY = b.y - a.y,
						dist = Math.sqrt((dX * dX) + (dY * dY));

					if (dist < a.radius + b.radius) {
						var angle = Math.atan2(dY, dX),
							sine = Math.sin(angle),
							cosine = Math.cos(angle);
						// rotating the circle angles to calcuate the direction to bounce
						var x = 0,
							y = 0;

						var xB = dX * cosine + dY * sine,
							yB = dY * cosine - dX * sine;

						var vXb = b.vX * cosine + b.vY * sine,
							vYb = b.vY * cosine - b.vX * sine;

						// reversing the velocity
						//vX += .1;
						//vXb += -1;

						// conservation of motion using mass and velocity
						var vTotal = vX - vXb;

						vX = ((a.mass - b.mass) * vX + 2 * b.mass * vXb) / (a.mass + b.mass);
						vXb = vTotal + vX;

						// move them apart so they dont stick together
						xB = x + (a.radius + b.radius);

						// rotate circles back to original positions
						a.x = a.x + (x * cosine - y * sine);
						a.y = a.y + (y * cosine + x * sine);

						b.x = a.x + (xB * cosine - yB * sine);
						b.y = a.y + (yB * cosine + xB * sine);

						a.vX = vX * cosine - vY * sine;
						a.vY = vY * cosine + vX * sine;

						b.vX = vXb * cosine - vYb * sine;
						b.vY = vYb * cosine - vXb * sine;
					}
				}

				// update the x and y axis with the velocity of each ball
				a.x += a.vX;
				a.y += a.vY;

				// add the acceleration
				a.aX = 0;
				a.aY = 0;

				if (Math.abs(a.vX) < 10 ) {
					a.vX += a.aX;
				}
				if (Math.abs(a.vY) < 10 ) {
					a.vY += a.aY;
				}

				// apply some friction
				if (Math.abs(a.vX) > 0.2) {
					a.vX *= 1;
				} else {
					a.vX = 1;
				}

				if (Math.abs(a.vY) > 0.2) {
					a.vY *= 1;
				} else {
					a.vY = 1;
				}

				// adding a boundry
				if (a.x - a.radius < 0) {
					a.x = a.radius;
					a.vX *= -1;
					a.aX *= -1;
				} else if (a.x + a.radius > canvas.width) {
					a.x = canvas.width - a.radius;
					a.vX *= -1;
					a.aX *= -1;
				}
				if (a.y - a.radius < 0) {
					a.y = a.radius;
					a.vY *= -1;
					a.aY *= -1;
				} else if (a.y + a.radius > canvas.height) {
					a.y = canvas.height - a.radius;
					a.vY *= -1;
					a.aY *= -1;
				}


				// draw the balls
				ctx.save();
					ctx.fillStyle = '#fff';

					ctx.beginPath();
						ctx.arc(a.x, a.y, a.radius, 0, Math.PI * 2, false);
						ctx.fill();
					ctx.closePath();
				ctx.restore();
			}
		}

		function calculateFps(now) {
			var fps = 1000 / (now - lastTime + duration);

			lastTime = now;
			return fps;
		}

		function animate(now) {
			paused = false;

			if (anti.timer.isRunning() && anti.timer.getElapsedTime() > duration) {
				anti.timer.stop();
				paused = true;
			}
			else {
				now = (now !== undefined) ? now : getTimeNow();
				fps = calculateFps(now);

				if (!paused) {
					//	console.log(lastTime);
					erase();
					draw();
				}
			}

			// erase();
			// draw();
			// animateBalls();
			requestNextAnimationFrame(animate);
		}

		// Event handlers

		// Initialization

		tree.src = 'imgs/smalltree.png';
		nearTree.src = 'imgs/tree-twotrunks.png';
		grass.src = 'imgs/grass.png';
		grass2.src = 'imgs/grass2.png';

		bCloud.src = 'imgs/clouds-m.png';
		mCloud.src = 'imgs/cloud-med.png';
		sCloud.src = 'imgs/cloud-small.png';
		sky.src = 'imgs/sky.png';

		sky.onload = function(e) {
			draw();
		};

		requestNextAnimationFrame(animate);
	},

	utils: {
		resizeToScreen: function() {
			var winW = window.innerWidth,
				winH = window.innerHeight;

			anti.layers.layer3.pos[2] = winW -(winW * 0.20);

			var thum = (anti.layers.layer3.pos[2] / 3.2) - 0.6 * 3 + 4;

			//console.log(anti.layers, thum);

			$('body').css({
				height: winH,
				width: winW
			});
			$('#layer3').css({
				width: (winW - (winW * 0.20) + 30) + 'px',
				height: winH + 'px',
				left: '100px'
			});
			$('.panel').css({
				//width: winW - (3 * $('#layer3').css('left').split('px')[0]) + 'px',
				height: winH - (winH * 0.179) + 'px'
			});

			var can = document.getElementById('bgGame');
			can.width = winW;
			can.height = winH - 70;

			// For the panels content like the defaults thumbnails,
			// resize the LI's to make bgImage size according to layer3 width
			if ($('#default-nav').length > 0) {
				//console.log($('.panel').css('width'));
				$('#default-nav').parent().css({
					//	width: thum + 4 +'px'
					height: Number($('#panel5').height()) -8 +'px'
				});
			}

			// Fix the title LI block
			document.getElementById('default-nav').getElementsByTagName('img')[0].onload = function() {
				//console.log('true');
				$('#default-nav li, #default-nav li a, #default-nav .panel5, #default-nav .panel5 a').height(this.height);
			};

			// If the window width has a smaller size then scale panel width up
			if (window.innerWidth < 1280) {
				$('body').css({
					height: winH,
					width: winW
				});
				$('#layer3').css({
					left: (window.innerWidth * 0.2) % 2 +'px',
					top: 0,
					width: winW - (winW * 0.05) + 'px',
					height: winH - (winH * 0.025) + 'px'
				});
				$('.panel .gallery img, .panel .gallery iframe').css({
					width: (winW - (winW * 0.05)) * 0.20 +'px'
				});
				$('.panel').css({
					paddingLeft: 0.500 +'em'
					//height: winH - (winH * 0.05) + 'px'
				});
			}
			if (winW > 1130) {
				$('#layer3').css({
					width: '1054px'
				});
			}
		},
		isArray: function(array) {
			return (array.constructor.toString().indexOf('Array') !== -1);
		},
		randomKey: function(array) {
			return array[Math.floor(Math.random() * array.length)];
		},
		keyExists: function(key, search) {
			if (!search || (search.constructor !== Array && search.constructor !== Object)) { return false; }
			for (var i = 0; i < search.length; i++) {
				if (search[i] === key) { return true; }
			}
			return key in search;
		}
	}
};

UTIL = {
	fire: function(func, funcname, args) {
		var namespace = anti;
		funcname = (funcname === undefined) ? 'init' : funcname;
		if (func !== '' && namespace[func] && typeof namespace[func][funcname] == 'function') {
			namespace[func][funcname](args);
		}
	},
	loadEvents: function() {
		var b = document.body;
		var bid = b.id;
		//console.log(bid);
		UTIL.fire('common');
		UTIL.fire(bid);
/*
		var classes = b.clasaname.split(/\s+/), test = classes.length;
		for (var i = 0; i < test; i++) {
			UTIL.fire(classes[i]);
			UTIL.fire(classes[i], bid);
		};
*/
		UTIL.fire('common', 'finalize');
	}
};
//kick it all off here
$(document).ready(UTIL.loadEvents);
$(document).ready(UTIL.loadEvents);