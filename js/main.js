/**
 * Update (1/12/13) - Not surprisingly since I made this site again Fall of 2012, just 4 months from when I started I now cannot
 * stand to see the js code I wrote to make it. It is disgusting. And I apologize. It is pretty cool still but ugh!! What the hell
 * was I thinking 4 months ago... Gonna have to redo it again now soon. Crazy how much you can learn and grow in just a short time.

 * This site is still being developed. Every example is loaded in the panels using ajax onclick of each nav link. All panels have
 * interactive and even "playable" demo examples loaded into this page. The background game I am working to integrate is still
 * being developed but my plan is to make it itself a playable game in the background of the page at all times.
 */

// The bmi.js library should be destroyed in a major way - ignore this half-ass partial hack
bmi_SafeAddOnload = null;

if (typeof anti !== 'object') {
	anti = {};
}

anti = {
	common: {
		init: function() {
			if ($('.lt-ie9').length) {
				console.log('Anti-Up!!');
			}

			// ie9 - Need to set cors to true for loading each projects assets
			$.support.cors = true;
			anti.init();
		}
	},
	/**!
	 * Stores the panels ID and CSS position coordinates for global access
	 * once generated by looping over the list of .panels
	 */
	panels: {
		activePanel: 'panel5',
		panelsLoaded: [],
		panelSliders: []
	},
	layers: {},

	init: function() {
		var b = document.body,
			p = $('.panel'),
			l = $('.layer');


		// load the initial panel's content
		anti.panels.panelsLoaded.push(anti.panels.activePanel);
		//anti.panelContent.loadPanel(anti.panels.activePanel);

		// Set up an obj of each PANEL and their left/top position
		// for (var i = 0; i < p.length; i++) {
		// 	var panelId = $(p[i]).attr('id');

		// 	// Skip the loading of panel5
		// 	if (i !== 4) {
		// 		$(p[i]).html('<div class="panel-wrap"></div>');
		// 	}
		// 	anti.panels[panelId] = {};
		// 	anti.panels[panelId].pos = [];
		// 	anti.panels[panelId].pos.push(
		// 		Number($('#'+ panelId).css('left').split('px')[0]),
		// 		Number($('#'+ panelId).css('top').split('px')[0])
		// 	);
		// }
		//console.log('panels: ', anti.panels);

        // Set up an obj of each LAYER and their left/top position
		// for (var j = 0; j < l.length; j++) {
		// 	var layerId = $(l[j]).attr('id');

		// 	anti.layers[layerId] = {};
		// 	anti.layers[layerId].pos = [];
		// 	anti.layers[layerId].pos.push(
		// 		Number($('#'+ layerId).css('left').split('px')[0]),
		// 		Number($('#'+ layerId).css('top').split('px')[0]),
		// 		Number($('#'+ layerId).css('width').split('px')[0]),
		// 		Number($('#'+ layerId).css('height').split('px')[0])
		// 	);
		// }

		// Setup navigation
		anti.panelNavigation.setUp();

		/*$('#default-nav').find('a').on('click', function(e) {
			e.preventDefault();
			$('#main-nav').animate({ right: 0 }, 200);
		});

		$('#main-nav a').on('click', function(e) {
			e.preventDefault();
			if ($(this).attr('href') === '#panel5') {
				$('#main-nav').animate({ right: -320 +'px' }, 200);
			} else {
				return;
			}
		});*/

		// Make everything fill the browser viewport
		if (window.attachEvent/* && window.addEventListener !== 'undefined'*/) {
			window.attachEvent('onresize', anti.utils.resizeToScreen);
		} else {
			window.addEventListener('resize', anti.utils.resizeToScreen, false);
		}
		anti.utils.resizeToScreen();

		anti.parallax();
		anti.time();
		//anti.canvas.init();
	},

	panelNavigation: {
		// Constants for nav functionality
		BASE_DURATION: 1000,
		MAX_DURATION: 4000,
		EASING_TYPE: 'easeOutQuart', // easeOutQuart',
		MENU_SET: $('#main-nav, #default-nav').find('a'),

		// sets up handlers on nav elements and maps handlers, with target params
		setUp: function() {
			$('#default-nav li a').hover(function() {
				$(this).find('span').stop().animate({ bottom: 40 +'px'}, 500);
			}, function() {
				$(this).find('span').stop().animate({ bottom: 0 }, 500);
			});

			anti.panelNavigation.MENU_SET.on('click', function(e) {
				var panelToLoad = $(this).attr('href').split('#')[1];

				//console.log('panelToLoad: ', anti.panels[panelToLoad]);
				anti.panelNavigation.navigateToSection(panelToLoad);

				e.preventDefault();
			});
		},
		navigateToSection: function(panelToLoad) {
			//window.history.pushState(panelToLoad, $('#'+ panelToLoad).find('h2').text(), '#'+ panelToLoad);
			//window.location.hash = '#'+ panelToLoad;

			$('#main-nav, #default-nav').find('.active').removeClass('active');
			$('#main-nav, #default-nav').find('a[href=#' + panelToLoad + ']').addClass('active');

			//console.log(anti.panels, panelToLoad, anti.layers);

			// set now to the section about to be loaded into view
			anti.panels.activePanel = panelToLoad;

			// load target panel's content
			anti.panelContent.loadPanel(panelToLoad);

			anti.panelNavigation.moveAll(panelToLoad);
		},

		// method accepts string of target panel for which to apply position translation animations
		// TODO: BIG TIME - this whole method needs to be done more abstractly and better!!!
		moveAll: function(panelToLoad) {
			//console.log('moveAll called!!');

			//console.log(anti.panels, anti.layers, panelToLoad);
			var winW = window.innerWidth,
				winH = window.innerHeight,
				leftPos = 100,
				topPos = 20;

			// For screens that are smaller than 1280
			if (winW < 1280) {
				leftPos = 10;
				topPos = 0;
			}

			var layer3pos = anti.panels[panelToLoad].pos !== 'undefined' ? anti.panels[panelToLoad].pos : '',
				layer3x = layer3pos[0] * -1 + leftPos,
				layer3y = layer3pos[1] * -1 + topPos;

			//	Eqaution: slope = ((y1 - y2) / (x1 - x2))

			// Slope difference of layer3
			//var slope = ((an.layerPos.layer3[1] - layer3y) / (an.layerPos.layer3[0] - layer3x));

			anti.layers.layer3.pos[2] = anti.panels.panel1.pos[0] - (anti.panels.panel3.pos[0] + winW);
			anti.layers.layer3.pos[3] = anti.panels.panel1.pos[1] - (anti.panels.panel3.pos[0] + winH);

			/**
			 * layer - anti.layer[layer].pos = [x, y, w, h]
			 *
			 * xConst/yConst = (panelToLoad.pos[x, y] - layer3[Width/Height]) * 0.0001; // times 10,000th
			 * layer1,4,5 x  = (layer1,4,5 Width / windowWidth) * ((panel.pos[x] - layer3width) * 0.0001) * 1000 * -1
			 * layers = anti.layer [x, y] - layer[x,y]
			 */
			var xConst = (anti.panels[panelToLoad].pos[0] - anti.layers.layer3.pos[2]) * 0.0001;
			var yConst = (anti.panels[panelToLoad].pos[1] - anti.layers.layer3.pos[3]) * 0.0001;

			//console.log(anti.layers.layer3.pos[2], anti.layers.layer3.pos[3], xConst);

			var layer1x = (anti.layers.layer1.pos[2]) / winW * xConst * 1000 * -1;
			var layer4x = (anti.layers.layer4.pos[2] / winW) * xConst * 1000 * -1;
			var layer5x = (anti.layers.layer5.pos[2] / winW) * xConst * 1000 * -1;

			var bCloudx = (Number(anti.layers.bigCloud.pos[2]) / winW) * xConst * 1000 * -1,
				bCloudy = (Number(anti.layers.bigCloud.pos[3]) / winH) * yConst * 1000 * -1;

			var mCloudx = (Number(anti.layers.medCloud.pos[2]) / winW) * xConst * 1000 * -1,
				mCloudy = (Number(anti.layers.medCloud.pos[3]) / winH) * yConst * 1000 * -1;

			var sCloudx = (Number(anti.layers.smCloud.pos[2]) / winW) * xConst * 1000 * -1,
				sCloudy = (Number(anti.layers.smCloud.pos[3]) / winH) * yConst * 1000 * -1;

			var layers = {
				layer3: [layer3x, layer3y],
				layer1: [
					anti.layers.layer1.pos[0] - layer1x,
					Number($('#layer1').css('bottom').split('px')[0])
				],
				layer4: [
					anti.layers.layer4.pos[0] - layer4x,
					Number($('#layer4').css('bottom').split('px')[0])
				],
				layer5: [
					anti.layers.layer5.pos[0] - layer5x,
					Number($('#layer5').css('bottom').split('px')[0])
				],
				bigCloud: [
					anti.layers.bigCloud.pos[0] - bCloudx,
					anti.layers.bigCloud.pos[1] - bCloudy
				],
				medCloud: [
					anti.layers.medCloud.pos[0] - mCloudx,
					anti.layers.medCloud.pos[1] - mCloudy
				],
				smCloud: [
					anti.layers.smCloud.pos[0] - sCloudx,
					anti.layers.smCloud.pos[1] - sCloudy
				]
			};

			anti.panelNavigation.animateEm(layers);
		},
		animateEm: function(layers) {
			// check for travel distance to set animation duration based on how far to slide
			var xDiff = Math.abs((anti.layers.layer3.pos[2] + 100000) - (layers.layer3[0] + 100000));
            // calculate the adjusted animation duration
            var thisDuration = (xDiff / (anti.layers.layer3.pos[2] * (anti.panelNavigation.MAX_DURATION - anti.panelNavigation.BASE_DURATION))) + anti.panelNavigation.BASE_DURATION;

			// run the animations
			$('#layer3').stop().animate({ left: layers.layer3[0] + 'px', top: layers.layer3[1] + 'px' }, thisDuration, anti.EASING_TYPE);

			$('#layer1').stop().animate({ left: layers.layer1[0] + 'px' }, thisDuration, anti.panelNavigation.EASING_TYPE);
			$('#layer4').stop().animate({ left: layers.layer4[0] + 'px' }, thisDuration, anti.panelNavigation.EASING_TYPE);
			$('#layer5').stop().animate({ left: layers.layer5[0] + 'px' }, thisDuration, anti.panelNavigation.EASING_TYPE);

			$('#bigCloud').stop().animate({
				left: layers.bigCloud[0] + 'px',
				top: layers.bigCloud[1] + 'px'
			}, thisDuration, anti.EASING_TYPE);

			$('#medCloud').stop().animate({
				left: layers.medCloud[0] + 'px',
				top: layers.medCloud[1] + 'px'
			}, thisDuration, anti.EASING_TYPE);

			$('#smCloud').stop().animate({
				left: layers.smCloud[0] + 'px',
				top: layers.smCloud[1] + 'px'
			}, thisDuration, anti.EASING_TYPE);
		}
	},
	panelContent: {
		loadPanel: function(panelTo) {
			// If the panelTo is a panel that has no content at this time, return now
			if (panelTo === 'panel14' || panelTo === 'panel15') return;

			var isLoaded = anti.utils.keyExists(panelTo, anti.panels.panelsLoaded);

			$('.panel').find('.panel-wrap').fadeOut(500);

			// Cache the files loaded for each panel and enable event firing afterDOMready for each
			// If the panel is already loaded then show the hidden panel-wrap
			if (isLoaded) {
				anti.panelContent.showPanelContent(panelTo);
			} else {
				anti.panelContent.loadPanelContent(panelTo);
			}
		},
		showPanelContent: function(panelToShow) {
			$('#'+ panelToShow).find('.panel-wrap').stop().delay(1000).fadeIn(500);
		},
		loadPanelContent: function(panelToLoad) {
			return $.ajax({
				crossDomain: true,
				type: 'POST',
				dataType: 'html',
				url: 'panels/' + panelToLoad + '/index.html'
			})
			.done(function(panelContent) {
				//panelContent
				$('#'+ panelToLoad).find('.panel-wrap').hide().html(panelContent);

				anti.panels.panelsLoaded.push(panelToLoad);
			})
			.fail(function(jqXHR, status, error) {
				if ($('.lt-ie9').length) {
					console.log('Status: '+ status +'"\n" Error: '+ error);
				}
			})
			.always(function() {
				anti.panelContent.makeSlider(panelToLoad);
				anti.panelContent.showPanelContent(panelToLoad);
			});
		},
		makeSlider: function(panel) {
			if ($('#'+ panel).find('.gallery-thumbs').length < 1) {
				return;
			}

			var width = Number($('.panel article .project-content').width()),
				thumbs = $('#'+ panel).find('.gallery-thumbs li'),
				gallery = $('#'+ panel).find('.gallery'),
				galleryStr = '<ul style="'+ width * thumbs.length +'px">',
				visibleSlide = 'hidden';

			// Add current class to first thumbnail image
			//$(thumbs[0]).find('a').addClass('current');

			// Loop over the thumbnails to generate the slides for each
			for (var i = 1; i < thumbs.length; i++) {
				//if (i === 0) return;

				var para = $(thumbs[i]).find('p'),
					href = $(thumbs[i]).find('a').attr('href').split('#')[1],
					video = $(thumbs[i]).find('a').attr('data-vid');

				//console.log(thumbs.length, thumbs[i], href);

				if (href === 'slide-1') {
					visibleSlide = 'active';
				} else {
					visibleSlide = '';
				}

				galleryStr += '<li id="'+ href +'" class="'+ visibleSlide +'">';

				// Is the slide displaying a video or an image
				if (typeof video !== 'undefined') {
					galleryStr += '<iframe src="'+ video +'" width="655" height="561" frameborder="0" allowfullscreen></iframe>';
				} else {
					galleryStr += '<img src="panels/'+ panel +'/'+ href +'.jpg" alt="'+ panel +' '+ href +'" />';
				}

				galleryStr += '<p>'+ para.text() +'</p></li>';
				para.remove();
			}
			galleryStr += '</ul>';
			gallery.append(galleryStr);

			if ($('#default-nav li a').length > 0) {
				$('#default-nav li a').css({ opacity: 0.7 });
				$('#default-nav li a').hover(function() {
					$(this).stop().css({ opacity: 1 });
				}, function() {
					$(this).stop().css({ opacity: 0.7 });
				});
			}

			// Create click handler for thumbnails so they show larger versions correctly
			thumbs.find('a').on('click', function(e) {
				e.preventDefault();

				// use href of thumbnail clicked to find slide ID to display
				var slide = $(this).attr('href');

				// swap the active state of the current thumbnail with clicked thumbnail
				thumbs.find('a').removeClass('current').animate({ opacity: 0.7 }, 200);
				$(this).addClass('current').animate({ opacity: 1 }, 200);

				// hide all slides before showing slide for clicked thumbnail
				gallery.find('li').removeClass('active').fadeOut(200);
				gallery.find(slide).addClass('active').fadeIn(200);
			});
		}
	},

	parallax: function() {
		// shim layer with setTimeout fallback
		window.requestAnimFrame = (function() {
		return  window.requestAnimationFrame       ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame    ||
				window.oRequestAnimationFrame      ||
				window.msRequestAnimationFrame     ||
				function( callback ) {
				window.setTimeout(callback, 1000 / 60);
			};
		})();

		(function(win, d) {
			var	w = window.innerWidth,
				h = d.height;

			var imgs = [ 'wave-1', 'wave-4', 'wave-5', 'clouds-b', 'clouds-m', 'clouds-s' ];

			var canvas = d.getElementById('#bgGame'),
				ctx = canvas.getContext('2d');

			var ticking = false;
				lastScrollX = 0,
				lastScrollY = 0;

			function onResize() {
				w = win.innerWidth;
				h = d.height;

				canvas.width = w;
				canvas.height = h;

				updateElements(win.scrollX, win.scrollY);
			}

			function onScroll(event) {
				if (! ticking) {
					ticking = true;

					requestAnimFrame( updateElements );

					lastScrollX = win.scrollX;
					lastScrollY = win.scrollY;
				}
			}

			function updateElements() {
				var relativeX = lastScrollX / w,
					relativeY = lastScrollY / h;

				ctx.fillStyle = 'hsla(223, 100%, 80%, 0.7)';
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				context.drawImage(blob1, 484, pos(254, -4400, relativeY, 0));
				context.drawImage(blob2, 84, pos(954, -5400, relativeY, 0));
				context.drawImage(blob3, 584, pos(1054, -3900, relativeY, 0));
				context.drawImage(blob4, 44, pos(1400, -6900, relativeY, 0));
				context.drawImage(blob5, -40, pos(1730, -5900, relativeY, 0));
				context.drawImage(blob6, 325, pos(2860, -7900, relativeY, 0));
				context.drawImage(blob7, 725, pos(2550, -4900, relativeY, 0));
				context.drawImage(blob8, 570, pos(2300, -3700, relativeY, 0));
				context.drawImage(blob9, 640, pos(3700, -9000, relativeY, 0));

				ticking = false;
			}

			function pos(base, range, relY, offset) {
				return base + limit(0, 1, relY - offset) * range;
			}

			function limit(min, max, value) {
				return Math.max(min, Math.min(max, value));
			}

			win.addEventListener('load', onResize, false);
			win.addEventListener('resize', onResize, false);
			win.addEventListener('scroll', onScroll, false);

		})(window, document);
	},

	time: function() {
		// Change background depending on user's time
		var d = new Date(),
			t = d.getHours();

		// If time is between 5am - 6am or 4pm - 5pm make dusk or dawn - steel blue
		if (t < 6 && t > 5 || t < 17 && t > 16) {
			$('body').addClass('morning').css({ background: 'hsla(215, 33%, 60%, 0.7)' });
		}
		// If time is between 9am and noon make it morning blue - bright skyblue
		else if (t > 12 && t > 9) {
			$('body').addClass('morning').css({ background: 'hsla(185, 100%, 51%, 0.7)' });
		}
		// If time is 7pm or later make it night - dark bg
		else if (t > 19) {
			$('body').addClass('night').css({ background: 'rgba(1, 1, 2, 0.7)' });
		}
		// If time is between 6am - 7am or 6pm â€“ 7pm sunset - red orange bg
		else if (t > 6 && t < 7 || t > 17 && t < 19) {
			$('body').addClass('sunset').css({ background: 'rgba(208, 58, 236, 0.7)' });
		}
		// Otherwise default to norma day blue - deep blue
		else {
			$('body').addClass('day').css({ background: 'hsla(223, 100%, 80%, 0.7)' });
		}
	},

	canvas: {
		canvas: null,
		ctx: null,

		init: function() {
			console.log('Canvas init');

			this.canvas = document.getElementById('bgGame');
			this.ctx = this.canvas.getContext('2d');
			var winWidth = window.innerWidth,
				winHeight = window.innerHeight;

			this.canvas.width = winWidth;
			this.canvas.height = winHeight;

			this.draw();
		},
		draw: function() {
			console.log(this);

			this.ctx.beginPath();
				this.ctx.fill();

		},
		update: function() {
			console.log(this);

		}
	},

	utils: {
		prefix: function(obj, prop, value) {
			var prefs = ['webkit', 'moz', 'o', 'ms'];
			for (var pref in prefs) {
				obj[prefs[pref] + prop] = value;
			}
		},
		resizeToScreen: function() {
			// TODO: This is horrible. clean it up bigtime

			anti.layers.layer3.pos[2] = window.innerWidth -(window.innerWidth * 0.20);

			var thum = (anti.layers.layer3.pos[2] / 3.2) - 0.6 * 3 + 4;

			//console.log(anti.layers, thum);

			$('body').css({
				height: window.innerHeight
			});
			$('#layer3').css({
				width: window.innerWidth - (window.innerWidth * 0.20) + 'px',
				height: window.innerHeight + 'px'
			});
			$('.panel').css({
				//width: window.innerWidth - (3 * $('#layer3').css('left').split('px')[0]) + 'px',
				height: window.innerHeight - (window.innerHeight * 0.179) + 'px'
			});

			// For the panels content like the defaults thumbnails,
			// resize the LI's to make bgImage size according to layer3 width
			if ($('#default-nav').length > 0) {
				//console.log($('.panel').css('width'));
				$('#default-nav').parent().css({
					//	width: thum + 4 +'px'
					height: Number($('#panel5').height()) -8 +'px'
				});
			}

			// If the window width has a smaller size then scale panel width up
			if (window.innerWidth < 1280) {
				$('#layer3').css({
					left: '10px',
					top: 0,
					width: window.innerWidth - (window.innerWidth * 0.05) + 'px',
					height: window.innerHeight - (window.innerHeight * 0.025) + 'px'
				});
				$('.panel .gallery img, .panel .gallery iframe').css({
					width: (window.innerWidth - (window.innerWidth * 0.05)) * 0.20 +'px'
				});
				$('.panel').css({
					paddingLeft: 0.500 +'em'
					//height: window.innerHeight - (window.innerHeight * 0.05) + 'px'
				});
			}
		},
		isArray: function(array) {
			return (array.constructor.toString().indexOf('Array') !== -1);
		},
		makeArray: function(obj) {
			return Array.prototype.slice.call(obj);
		},
		randomKey: function(array) {
			return array[Math.floor(Math.random() * array.length)];
		},
		keyExists: function(key, search) {
			if (!search || (search.constructor !== Array && search.constructor !== Object)) { return false; }
			for (var i = 0; i < search.length; i++) {
				if (search[i] === key) { return true; }
			}
			return key in search;
		},
		extend: function(d, e, c) {
			var b = function() {}, a;
			b.prototype = e.prototype;
			d.prototype = new b();
			d.prototype.constructor = d;
			d.superclass = e.prototype;
			if (e.prototype.constructor == Object.prototype.constructor) {
				e.prototype.constructor = e;
			}
			if (c) {
				for (a in c) {
					if (c.hasOwnPropterty(a)) {
						d.prototype[a] = c[a];
					}
				}
			}
		},
		createCache: function(requestFunction) {
			var cache = {};
			return function(key, callback) {
				if (!cache[key]) {
					cache[key] = $.Deferred(function(defer) {
						requestFunction(defer, key);
					}).promise();
				}
				return cache[key].done(callback);
			};
		}
	}
};

UTIL = {
	fire: function(func, funcname, args) {
		var namespace = anti;
		funcname = (funcname === undefined) ? 'init' : funcname;
		if (func !== '' && namespace[func] && typeof namespace[func][funcname] == 'function') {
			namespace[func][funcname](args);
		}
	},
	loadEvents: function() {
		var b = document.body;
		var bid = b.id;
		//console.log(bid);
		UTIL.fire('common');
		UTIL.fire(bid);
/*
		var classes = b.clasaname.split(/\s+/), test = classes.length;
		for (var i = 0; i < test; i++) {
			UTIL.fire(classes[i]);
			UTIL.fire(classes[i], bid);
		};
*/
		UTIL.fire('common', 'finalize');
	}
};
//kick it all off here
$(document).ready(UTIL.loadEvents);



// /* * * * * * * * * * * * * * * * * * * * * * * * * * * */
// /* * * * * * * * * * * * * * * * * * * * * * * * * * * */
// /* * * * * * * * * * * * * * * * * * * * * * * * * * * */

// 	var reqAnimFrame = window.requestAnimationFrame 	  ||
// 					   window.webkitRequestAnimationFrame ||
// 					   window.mozRequestAnimationFrame 	  ||
// 					   function(func) { setTimeout(func, 17); };

// 	var html = document.documentElement;

// 	function Flake() {
// 		this.reset(maxX);
// 	}

// 	Flake.prototype = {
// 		tick: function() {
// 			var sidePhase = this.sidePhase = this.sideVel;
// 			this.x += this.sideVel;
// 			this.y += this.vel;
// 		},
// 		reset: function(maxX) {
// 			var rand = Math.random(),
// 				chanceOfLargeFlake = 0.15;

// 			this.size = 2 + rand * 5;
// 			this.vel = 3 + rand * 3;
// 			this.alpha = 0.5 + rand * 0.8;

// 			// random x position
// 			this.x = rand * maxX;
// 			this.y = -this.size;

// 			// side to side movement
// 			this.sideVel = (0.5 - rand) * this.vel;

// 			return this;
// 		}
// 	};



//   (function() {
//     var canvas = document.createElement('canvas');
//     var context = canvas.getContext('2d');
//     var settleCanvas = document.createElement('canvas');
//     var settleContext = context && settleCanvas.getContext('2d');
//     var canvasStyle = canvas.style;
//     var settleCanvasStyle = settleCanvas.style;
//     var windowResized;
//     var activeFlakes = [];
//     var snowflakesPerPixelPerSecond = 0.05;
//     var PIx2 = Math.PI*2;
//     var assumedFps = 60;
//     var settlePoint;
//     var snowflakePool = [];

//     function resizeCanvas() {
//       settlePoint = Array(html.clientWidth);
//       settleCanvas.width = canvas.width = html.clientWidth;
//       settleCanvas.height = canvas.height = html.clientHeight;
//     }

//     function updateSettlePoints(flake) {
//       var size = flake.size * 0.8; // reduce coral effect
//       var xStart = Math.floor(flake.x - size);
//       var range = size * 2;
//       var newY;

//       if (xStart < 0) {
//         range += xStart;
//         xStart = 0;
//       }
//       if (xStart + range > settlePoint.length) {
//         range -= xStart + range - settlePoint.length;
//       }

//       for (var i = 0; i < range; i++) {
//         newY = flake.y - (size * Math.cos( (i/range) * Math.PI - (Math.PI/2) ));
//         settlePoint[i + xStart] = Math.min(settlePoint[i + xStart] || Infinity, newY);
//       }
//     }

//     var flakesToCreate = 0;
//     function frame() {
//       flakesToCreate += (snowflakesPerPixelPerSecond / assumedFps) * canvas.width;
//       var flakesThisFrame = Math.floor(flakesToCreate);
//       flakesToCreate -= flakesThisFrame;

//       // clear canvas
//       if (windowResized) {
//         resizeCanvas();
//         windowResized = false;
//       }
//       else {
//         context.clearRect(0, 0, canvas.width, canvas.height);
//       }

//       // add new flake?
//       while ( flakesThisFrame-- ) {
//         if (snowflakePool.length) {
//           activeFlakes.push( snowflakePool.pop().reset(canvas.width) );
//         }
//         else {
//           activeFlakes.push( new Snowflake(canvas.width) );
//         }
//       }

//       var i = activeFlakes.length;
//       var flake;

//       // for each flake...
//       while (i--) {
//         flake = activeFlakes[i];
//         flake.tick();

//         // splice flake if it's now out of rendering zone
//         if (flake.y >= canvas.height || flake.y >= settlePoint[Math.floor(flake.x)]) {
//           snowflakePool.push.apply(snowflakePool, activeFlakes.splice(i, 1));
//           // this flake effects our settle points
//           if (flake.alpha > 0.8) {
//             updateSettlePoints(flake);
//           }
//           settleContext.fillStyle='rgba(255, 255, 255, ' + flake.alpha + ')';
//           settleContext.beginPath();
//           settleContext.arc(flake.x, flake.y, flake.size, 0, PIx2, true);
//           settleContext.closePath();
//           settleContext.fill();
//           continue;
//         }

//         // render to canvas
//         context.fillStyle='rgba(255, 255, 255, ' + flake.alpha + ')';
//         context.beginPath();
//         context.arc(flake.x, flake.y, flake.size, 0, PIx2, true);
//         context.closePath();
//         context.fill();
//       }
//       requestAnimationFrame(frame);
//     }

//     if (context) {
//       resizeCanvas();

//       // style the canvas
//       canvasStyle.position = 'fixed';
//       canvasStyle.top = 0;
//       canvasStyle.left = 0;
//       canvasStyle.zIndex = 1138;
//       canvasStyle['pointerEvents'] = 'none';

//       settleCanvasStyle.cssText = canvasStyle.cssText;

//       // watch out for resizes
//       window.addEventListener('resize', function() {
//         windowResized = true;
//       }, false);

//       // add it to the page & start animating
//       document.body.appendChild(canvas);
//       document.body.appendChild(settleCanvas);
//       requestAnimationFrame(frame);
//     }
//   })();

// })();